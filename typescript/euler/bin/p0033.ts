
// project euler: problem 33

/*
  case #1: (10a + c) / (10c + b) = a / b
  case #2: (10a + c) / (10b + c) = a / b
  case #3: (10c + a) / (10c + b) = a / b
  case #4: (10c + a) / (10b + c) = a / b
    // prerequisite: a < b

  #1:
      10ab + bc = 10ac + ab
   -> 9ab = 10ac - bc
   -> 9ab - 9ac = ac - bc
   -> 9a(b - c) = c(a - b)
   -> 9a(c - b) = c(b - a)  [a < b => a < b < c]
  #2:
      10ab + bc = 10ab + ac
   -> bc = ac
   -> b = a   ==> NG (contradiction)
  #3:
      10bc + ab = 10ac + ab
   -> 10bc = 10ac
   -> b = a   ==> NG (contradiction)
  #4:
      10bc + ab = 10ab + ac
   -> 10bc - ac = 9ab
   -> bc - ac = 9ab - 9bc
   -> c(b - a) = 9b(a - c)  [a < b => c < a < b]
   -> a - c = c/9 - ac/9b => 1   ==> NG (bacause c/9 < 1)

  I only need to search in case #1.
*/

import { combinations } from "combinatorics/mod.ts";
import { gcd } from "../lib/math.ts";
import { range } from "../lib/util.ts";

function makeCands(): [number, number][] {
  // Note: The function check() assumes that a < b < c.
  //
  // The combination list which are generated by combinations() are emitted
  // in lexicographic ordering according to the order of the input iterable.
  function check(a: number, b: number, c: number): boolean {
    return 9 * a * (c - b) === c * (b - a);
  }

  const acc: [number, number][] = [];

  for (const [a, b, c] of combinations(range(1, 10), 3)) {
    if (check(a, b, c) === true) {
      acc.push([a, b]);
    }
  }

  return acc;
}

export function compute(): string {
  const [a, b] = makeCands().reduce((acc, cur) => [acc[0] * cur[0], acc[1] * cur[1]]);

  return String(Math.trunc(b / gcd(a, b)));
}

export function solve(): void {
  const t0 = performance.now();
  const result = compute();
  const t1 = performance.now();
  const duration_ms = (t1 - t0).toFixed(4);

  console.log(`Answer: ${result}`);
  console.log(`Elapsed time: ${duration_ms} msec.`);

  return;
}
