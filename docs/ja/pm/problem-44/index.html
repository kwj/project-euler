<!DOCTYPE html>
<html lang="ja"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <title>Problem 44 | Project Euler 感想戦</title>
  
  <link rel="stylesheet" href="/project-euler/css/style.css" />
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>


</head>
<body>
    <header><div class="top-menu">
  <div class="top-menu-group-left">

    <div class="top-menu-group-left-item">
      <a href="/project-euler/ja/">Home</a>
    </div>

    <div class="top-menu-group-left-item">
      <a href="https://github.com/kwj/project-euler/">GitHub</a>
    </div>

  </div>
  <div class="top-menu-group-right">

  </div>
</div>

<section class="content-meta">
  <h1><span class="title">Problem 44</span></h1>
</section>
</header>
    <main id="content">
<h2 id="問題へのリンク">問題へのリンク</h2>
<ul>
<li><a href="https://projecteuler.net/problem=44">Pentagon numbers</a></li>
</ul>
<h2 id="感想">感想</h2>
<p>きちんと解くには少し工夫が必要な問題。
最小の $D=P_{d}= |P_{k}-P_{j}|$ をどう保証するかが鍵になる。</p>
<h3 id="jk-から調べる方法">$j,k$ から調べる方法</h3>
<p>和と差の条件を満たす五角数 $P_{j}, P_{k}$ について、
$j,k$ が小さい値から調べると早い段階で見つかる。
この時の差 $|P_{k}-P_{j}|$ を $P_{d}$ とする。
この時点では $P_{d}$ が条件を満たす最小の五角数であるとは判断できません。
$P_{k}+P_{j}$ と $P_{d} = |P_{k}-P_{j}|$ の両方が五角数である $j,k$ を小さい方から探すときに
$P_{d}$ も小さい順に見つかるという主張をしている方もおられますが、
この主張が正しくない理由はセクション「余談」を参照のこと。</p>
<p>この $P_{d}$ が最小であることを確認するには $P_{n+1}-P_{n} = 3n-2 &gt; P_{d}$ となるまで、
和と差が五角数になる任意の五角数のペアについて、その差が
$P_{d}$ より小さいものが存在しないことを調べる必要がある。
存在した場合は終了条件を更新して捜索を続ける。ところがこの捜索範囲が非常に大きくなるため、
適切な枝刈りをしないと計算に時間がかかる。
枝刈りをすれば比較的短い時間で終わる（捜索中に $P_{a}-P_{b}&gt;P_{d}$ となったら大きさが $P_{b}$ 以下の項は不要）。</p>
<p>つまり力技による捜索です。</p>
<p>本問題では結果として最初の $P_{d}$ が条件を満たす最小の五角数 $D = P_{d}$ になっていることもあり、
フォーラムの投稿を見ると最初の $P_{d}$ を見つけた時点で捜索終了しているケースが多いです。
しかも $j,k$ に 5000 などの上限を決め打ち設定して開始する解法も見受けられました。
これらは最小性の確認をしておらず、答えは正しいが解法は正しくないパターンです。</p>
<h3 id="d-から調べる方法">$d$ から調べる方法</h3>
<p>先ほど「条件を満たす $P_{d}$ を見つけてから最小であるか否かを確認」したが、
発想を転換して「条件を満たす $P_{d}$ が存在するには何が必要か」を考える。</p>
<p>例えば、ある $d$ に対して五角数 $P_{d} = |P_{k}-P_{j}| = P_{k}-P_{j}$ になる $j,k \enspace (k&gt;j)$ が
存在すると仮定する。$P_{n+1}-P_{n}=3n-2 \;[n&gt;0]$ は単調増加なので $k-j&lt;d$。
そこで $x=k-j \;[0&lt;x&lt;d]$ とおいて $P_{d}=P_{x+j}-P_{j}$ を $j= \ldots$ の形に変形する。
逆に $j$ を消して $k= \ldots$ の形でも構わないが、
$k$ を消す方がプログラムで少しだけ扱いやすい式になる。</p>
<p>変形した結果は下記のとおりで、右辺は $d$ と $x$ から構成されています。</p>
<p>$$
j = \frac{P_{d}-P_{x}}{3x}
$$</p>
<p>つまり右辺が $3x$ で割り切れて自然数になる $d,x$ が見つかれば自然数 $j$ が存在し、
$k=x+j$ より $k$ も求まり $P_{d} = |P_{k}-P_{j}|$ となる $j,k$ を見つけたことになる。
そこで $d=1,2,\ldots$ と $d$ が小さい方から条件を満たす $d,x$ を探します。
そのような $d,x$ が見つかったときの $j,k$ の値において $P_{k}+P_{j}$ が五角数であれば、
この時の $P_{d}$ が求める最小の $D=P_{d}= |P_{k}-P_{j}|$ である。
$d$ を小さい値から調べることで最初に最小の $D$ が見つかることが保証されます。</p>
<p>さらに右辺が自然数なら分子は 3 の倍数になるので、
$P_{d}-P_{x} \equiv 0 \; (mod \, 3)$ から $x \equiv d \; (mod \, 3)$ を導くことができる。
これにより $0&lt;x&lt;d$ のうち調べる必要がある $x$ の量を約 1/3 に削減できます。
些細なことですが、$d$ の最小値も 1 ではなく 4 であることがわかります。</p>
<p>同じくフォーラムを覗いたら、固定ログで残されている範囲に上記の解法も投稿されていました。</p>
<h3 id="余談">余談</h3>
<p>後者の方法で $d \le 100,000$ の範囲を検索すると条件を満たす $P_{d}$ が 4 個見つかります
(本問題の解答は $***$ でマスクしました)。</p>
<p>$$
\begin{array}{cccc}
\hline
d &amp; P_{d} &amp; j &amp; k \\
\hline
****  &amp; ******* &amp; **** &amp; **** \\
46303 &amp; 3215928562 &amp; 111972 &amp; 121168 \\
55500 &amp; 4620347250 &amp; 95506 &amp; 110461 \\
75172 &amp; 8476206790 &amp; 52430 &amp; 91650 \\
\hline
\end{array}
$$</p>
<p>これを $max(j,k)$ をキーとして昇順にソートすると以下の通り。</p>
<p>$$
\begin{array}{cccc}
\hline
d &amp; P_{d} &amp; j &amp; k \\
\hline
**** &amp;  ******* &amp; **** &amp; **** \\
75172 &amp; 8476206790 &amp; 52430 &amp; 91650 \\
55500 &amp; 4620347250 &amp; 95506 &amp; 110461 \\
46303 &amp; 3215928562 &amp; 111972 &amp; 121168 \\
\hline
\end{array}
$$</p>
<p>前者の小さい $j,k$ から調べる方法で 2 番目に見つかる $P_{d}=P_{75172}$ は、
実は 4 番目に小さい $P_{d}$ であることが判ります。</p>
<p>この結果は $P_{d} = |P_{k} - P_{j}|$ と $P_{k} + P_{j}$ が五角数になるよう $j,k$ を
小さい値から順に探したとき、$P_{d}$ が必ず小さい順に見つかるという仮説を否定します。
つまり $j,k$ から調べる方針で正しく解くには、ある $P_{d}$ を見つけたら最小値であることの
確認も必須となります。</p>
<p>後者の方法は前者と違って $d$ が小さい方から調べるので $P_{d}$ も小さい順番に見つかります。
最初の $P_{d}$ が早期に見つかるので本問題では十分速いのですが、
その先を調べようとすると実は $d$ が大きくなったときに処理に時間がかかり遅いのが目立ちます。</p>
<p>そこで $P_{d}=P_{k}-P_{j}$ から
$$d(3d-1) = (k-j)(3(k+j)-1)$$
とできるので、$x=k-j, \, y=k+j$ とおいて $d(3d-1)$ の約数として
$x \; [0&lt;x&lt;d, \: d \equiv x \: (mod \, 3)]$ の候補を列挙して、$(3y-1) = d(3d-1)/x \equiv 2 \: (mod \, 3)$
かつ $(x+y) \equiv 0 \: (mod \, 2)$ を満たす $x,y$ を探すのが良いかもしれません。
$j=(P_{d}-P_{x})/3x$ の式から求めるよりもロジックは多少複雑になりますが、
五角数 $P_{x}$ の計算が無くなるのに加えて、効率的に約数を求められれば計算量の削減を期待できます。</p>
<p>幸いにも $d$ と $3d-1$ は互いに素なので、
$d(3d-1)$ の素因数分解は $d$ と $3d-1$ を個別に素因数分解した結果を単に合成するだけで求まります。
フォーラムには約数を求めるのに $0&lt;x&lt;d$ の範囲で試し割りをするポストがありましたが、
厳密に計算量を考察していないものの $d$ が大きい場合は上記の素因数分解から約数を求める方が格段に速くなる筈です。</p>
<h3 id="追記d-から調べる方法-その2">追記（$d$ から調べる方法 その2）</h3>
<p>$d(3d-1)$ を素因数分解して求めた約数から条件を確認する方式で実装したところ性能が向上しました。</p>
<p>実行環境は Raspberry Pi 4 Model B で Python 3.9.7 を使用。
$j=(P_{d}-P_{x})/3x$ の式から最小の $D$ を見つけるのに 0.4〜0.5 秒かかっていたのが約 0.2 秒になり、
$d \le 100,000$ の範囲を調査するのに約 25 分かかっていたのが約 21 秒で終了。</p>
<p>$d \le 1,000,000$ まで調べても所要時間は約 6 分でした。</p>
<pre tabindex="0"><code>$ ./solve-44.py 1000000
(****, ****, ****, *******)
(46303, 111972, 121168, 3215928562)
(55500, 95506, 110461, 4620347250)
(75172, 52430, 91650, 8476206790)
(106084, 73745, 129198, 16880669542)
(124333, 186517, 224159, 23187980167)
(326283, 3272845, 3289069, 159690730992)
(601500, 678531, 906756, 542703074250)
(767380, 1471972, 1659992, 883307712910)
Elapsed time: 360.126439 sec.
$ 
</code></pre><p>$0&lt;x&lt;d$ の範囲で試し割りして約数を求める方法の場合、最小の $D$ を見つけるのは素因数分解より早いですが、
$d$ が大きくなるにつれて遅くなり $d \le 100,000$ の範囲を調査するのに約 7 分強かかりました。</p>
<p>予想通り、$d$ が大きくなったときの性能にアルゴリズム変更が効いているのがわかります。</p>
<p>この Problem 44 は適当にやっても正答が出ることもあって問題の評価が少し悪いようですが、
$j,k$ から調べた時に最小であることを確認しているか（枝刈りができているか）、
それとも最初から最小の値を求めるために $d$ から調べているかなど、
解く側のスキルを見る観点からは面白い問題だと思います。</p>

<hr>
<div class="PrevNextLink">
  <div class="PrevNextLink_prev">

    <a href="https://kwj.github.io/project-euler/ja/pm/problem-43/">≪ Problem 43</a>

  </div>
  <div class="PrevNextLink_up">
    <a href="../">[Up]</a>
  </div>
  <div class="PrevNextLink_next">

    <a href="https://kwj.github.io/project-euler/ja/pm/problme-45/">Problem 45 ≫</a>

  </div>
</div>


    </main><footer>
  <div class="footer">
  
  
  <span class="copyright">
  <p>© 2021 Jun Kawai</p>
  </span>
  
  </div>
</footer>
</body>
</html>
